# AI-SDLC

A spec-driven development system for building products with AI. Combines the PM rigor of structured specs with the execution engine of phase-based AI coding.

**Three territories, one flow:**

```
PM writes specs/  →  Designer fills design/  →  Engineer builds with .planning/
                          ↓
                    AGENTS.md (auto-generated map)
                          ↓
              discuss → plan → execute → verify
                          ↓
                    Shipped product
```

## Philosophy

Most AI coding tools skip the hard part. You describe an idea, AI generates code, and you get inconsistent results that fall apart at scale. The problem isn't the AI — it's the inputs.

This system enforces a simple rule: **spec before code.** Every feature needs a JTBD spec. Every domain rule needs documentation. Every phase gets explicit implementation decisions before planning starts. The AI reads these specs and builds exactly what was specified.

The result: product decisions live in specs (where PMs can review them), not buried in prompts or code comments.

## Quick Start

### New Project (Greenfield)

```bash
cd your-project
# Copy this template into your project
cp -r ai-sdlc/* .
cp -r ai-sdlc/.claude .

# Launch Claude Code
claude

# Bootstrap
/ai-sdlc:init
```

### Existing Project (Brownfield)

```bash
# Copy template files
cp -r ai-sdlc/.claude .
cp -r ai-sdlc/specs .
cp -r ai-sdlc/design .
cp -r ai-sdlc/.planning .
cp ai-sdlc/CLAUDE.md .

# Launch Claude Code
claude

# Map your codebase first
/ai-sdlc:map-codebase

# Then bootstrap
/ai-sdlc:init
```

## Commands

| Command | Phase | What It Does |
|---------|-------|-------------|
| `/ai-sdlc:init` | Setup | Bootstrap project: questions → specs → roadmap |
| `/ai-sdlc:spec-draft` | PM | Coach through JTBD spec creation |
| `/ai-sdlc:domain-capture` | PM | Extract business rules from conversation |
| `/ai-sdlc:spec-review` | PM | Multi-agent review (engineer, designer, skeptic) |
| `/ai-sdlc:design-phase N` | Design | Generate components, flows, prototype specs |
| `/ai-sdlc:prototype` | Design | Create interactive HTML/React prototype |
| `/ai-sdlc:discuss-phase N` | Build | Shape implementation decisions |
| `/ai-sdlc:plan-phase N` | Build | Research + task plans + Ralph prompts |
| `/ai-sdlc:execute-phase N` | Build | Print instructions for Ralph loop |
| `/ai-sdlc:verify-work N` | Build | UAT + route fixes to Ralph loop |
| `/ai-sdlc:quick` | Build | Ad-hoc task with SDLC guarantees |
| `/ai-sdlc:progress` | Nav | Where am I? What's next? |
| `/ai-sdlc:map-codebase` | Nav | Analyze existing codebase |
| `/ai-sdlc:generate-agents` | Nav | Rebuild AGENTS.md |

## Directory Structure

```
project/
├── CLAUDE.md                    # System prompt (read by Claude Code)
├── AGENTS.md                    # Auto-generated project map
├── PROJECT.md                   # Vision, problem, hypothesis
├── REQUIREMENTS.md              # v1 / v2 / out-of-scope
├── ROADMAP.md                   # Phases + progress
│
├── specs/                       # [PM TERRITORY]
│   ├── jobs/                    # JTBD specs (product decisions)
│   └── domain/                  # Business rules (timeless truth)
│
├── design/                      # [DESIGNER TERRITORY]
│   ├── components.md            # Component catalog
│   ├── flows.md                 # User flows
│   └── prototype/               # Per-feature UI specs
│
├── STACK.md                     # [ENGINEER TERRITORY]
├── ARCHITECTURE.md              # System design
├── CONVENTIONS.md               # Code patterns
│
├── .planning/                   # Execution state
│   ├── STATE.md                 # Living memory
│   └── phases/                  # Per-phase work
│       └── 01-phase-name/
│           ├── CONTEXT.md       # Implementation decisions (from discuss-phase)
│           ├── RESEARCH.md      # Technical research (from plan-phase)
│           ├── PLAN.md          # XML task plans (from plan-phase)
│           ├── PROMPT_build.md  # Ralph build prompt (from plan-phase)
│           ├── PROMPT_plan.md   # Ralph planning prompt
│           ├── PROMPT_fix.md    # Ralph fix prompt
│           ├── IMPLEMENTATION.md # What was built (generated by Ralph)
│           ├── SUMMARY.md       # Phase completion report (generated by Ralph)
│           └── UAT.md           # User acceptance test results
│
├── .claude/
│   ├── commands/ai-sdlc/        # Slash commands
│   └── agents/                  # Sub-agent definitions
│
├── scripts/
│   └── loop.sh                  # Ralph Wiggum loop (run outside Claude Code)
│
└── docs/                        # Methodology docs
```

## Who Fills What

| File | Owner | When |
|------|-------|------|
| PROJECT.md | PM | Project kickoff |
| REQUIREMENTS.md | PM | After discovery |
| specs/jobs/*.md | PM (or PMCoach) | Before each feature |
| specs/domain/*.md | PM (or PMCoach) | When domain rules surface |
| design/*.md | Designer (AI-assisted) | After specs, via /ai-sdlc:design-phase |
| STACK.md | Engineer | Project kickoff |
| ARCHITECTURE.md | Engineer | After specs review |
| CONVENTIONS.md | Engineer | Project kickoff |
| .planning/* | System (AI) | During execution |
| AGENTS.md | System (auto) | Regenerated on changes |

## The Ralph Loop

Execution uses the **Ralph Wiggum technique** — an autonomous loop that runs OUTSIDE Claude Code in a regular terminal. This gives fresh context per iteration, preventing the quality degradation that happens as context windows fill up.

```bash
# After /ai-sdlc:plan-phase generates PROMPT_*.md files:

./scripts/loop.sh build 01-core-feature    # Build tasks one by one
./scripts/loop.sh plan 01-core-feature     # Analyze & update plan
./scripts/loop.sh fix 01-core-feature      # Fix UAT failures
./scripts/loop.sh build 01-core-feature 10 # Max 10 iterations
```

The loop:
1. Pipes `PROMPT_{mode}.md` to `claude -p --dangerously-skip-permissions`
2. Claude reads PLAN.md, implements the next task, commits
3. Loop pushes to git and restarts with fresh context
4. Repeats until all tasks complete or you hit Ctrl+C

This trades interactive control for autonomous execution. Run it in a Docker container or sandboxed environment.

## PMCoach Integration

This repo is the output target for PMCoach. PMCoach coaches PMs through spec creation and writes directly to `specs/`. You don't need PMCoach to use this repo — specs can be created manually or via `/ai-sdlc:spec-draft`. PMCoach just makes it faster and higher quality.

## Examples

See `examples/` for complete worked examples of the framework in action:
- **jha-safety-forms/** — Mobile safety compliance forms for construction (shows specs, domain rules, planning, and implementation)

## Credits

Built on patterns from:
- **[Ralph Wiggum](https://github.com/ghuntley/how-to-ralph-wiggum)** — Autonomous loop execution with fresh context per iteration
- **GSD** (TÂCHES) — Phase execution, XML tasks, multi-agent orchestration
- **PM-OS** — Skills architecture, sub-agent reviewers, context management
- **AI-SDLC Framework** — Role separation, AGENTS.md, domain persistence
